<!DOCTYPE html>
<html>
<head>
    <title>Phaser and Matter.js Game</title>
    <script src="https://cdn.jsdelivr.net/npm/phaser@3.55.2/dist/phaser.js"></script>
</head>
<body>
    <div id="ranking-area" style="position: absolute; top: 10px; right: 10px; width: 220px; background-color: rgba(0,0,0,0.5); color: white; padding: 10px; font-family: sans-serif; font-size: 14px; border-radius: 5px;">
        <h3>Local Ranking</h3>
        <ol id="ranking-list" style="list-style-type: decimal; padding-left: 20px; margin-top: 5px; margin-bottom: 10px;"></ol>
        <button id="clear-ranking-button" style="margin-top: 10px; padding: 5px; width: 100%; box-sizing: border-box;">Clear Ranking</button>
    </div>
    <script>
        // Function to display ranking
        function displayRanking() {
            const rankingListEl = document.getElementById('ranking-list');
            const scores = JSON.parse(localStorage.getItem('lanternGameScores')) || [];
            
            rankingListEl.innerHTML = ''; // Clear existing list

            if (scores && scores.length > 0) {
                scores.forEach(score => {
                    const listItem = document.createElement('li');
                    listItem.textContent = `${score.nickname} - ${score.time}s (${score.date})`;
                    rankingListEl.appendChild(listItem);
                });
            } else {
                const listItem = document.createElement('li');
                listItem.textContent = 'No scores yet!';
                rankingListEl.appendChild(listItem);
            }
        }

        const config = {
            type: Phaser.AUTO,
            width: 800,
            height: 600,
            backgroundColor: '#222222',
            physics: {
                default: 'matter',
                matter: {
                    gravity: { y: 1 }
                }
            },
            scene: {
                preload: function () {
                    // Dynamically create a white circle image for the lantern
                    const graphics = this.make.graphics({ x: 0, y: 0, add: false });
                    graphics.fillStyle(0xffffff);
                    graphics.fillCircle(16, 16, 16); // x, y, radius
                    graphics.generateTexture('lantern', 32, 32);
                    graphics.destroy();
                },
                create: function () {
                    // Add the lantern sprite to the center of the screen
                    const lanternSprite = this.matter.add.sprite(400, 50, 'lantern', null, {
                        shape: { type: 'circle', radius: 16 },
                        restitution: 0.1,
                        mass: 0.5
                    });

                    // Game state variable
                    let gameState = 'playing'; // 'playing', 'cleared', 'gameOver'

                    // Timer variables
                    let startTime = 0;
                    let elapsedTime = 0;
                    let timerText;

                    // Score submission flag
                    let scoreSubmitted = false;

                    // Tendril variables
                    let tendril = null;
                    let isTendrilActive = false;
                    const tendrilGraphics = this.add.graphics();
                    const memoryFragments = [];

                    // --- Create Memory Fragments ---
                    const fragmentGraphics = this.add.graphics();
                    fragmentGraphics.fillStyle(0x888888); // Grey color for fragments

                    function drawVertices(graphics, body) {
                        graphics.beginPath();
                        graphics.moveTo(body.vertices[0].x, body.vertices[0].y);
                        for (let i = 1; i < body.vertices.length; i++) {
                            graphics.lineTo(body.vertices[i].x, body.vertices[i].y);
                        }
                        graphics.closePath();
                        graphics.fillPath();
                    }

                    // Large platform
                    const largePlatform = this.matter.add.rectangle(400, 500, 600, 50, { 
                        isStatic: true, 
                        label: 'platform', 
                        chamfer: { radius: 10 } 
                    });
                    memoryFragments.push(largePlatform);
                    drawVertices(fragmentGraphics, largePlatform);

                    // Small ledges
                    const smallLedge1 = this.matter.add.rectangle(200, 350, 100, 30, { isStatic: true, label: 'small_ledge' });
                    memoryFragments.push(smallLedge1);
                    drawVertices(fragmentGraphics, smallLedge1);

                    const smallLedge2 = this.matter.add.rectangle(600, 250, 100, 30, { isStatic: true, label: 'small_ledge' });
                    memoryFragments.push(smallLedge2);
                    drawVertices(fragmentGraphics, smallLedge2);

                    // Slanted rectangle
                    const slantedRect = this.matter.add.rectangle(300, 150, 150, 20, { 
                        isStatic: true, 
                        label: 'slanted_platform', 
                        angle: Math.PI / 6 
                    });
                    memoryFragments.push(slantedRect);
                    drawVertices(fragmentGraphics, slantedRect);

                    // Initialize and display timer text
                    timerText = this.add.text(10, 10, 'Time: 0s', { fontSize: '16px', fill: '#fff' });
                    startTime = this.time.now; // Start timer

                    // Mouse input events
                    this.input.on('pointerdown', (pointer) => {
                        if (gameState !== 'playing') return; // Only allow input if playing

                        isTendrilActive = true;
                        const bodiesUnderPointer = Matter.Query.point(memoryFragments, { x: pointer.x, y: pointer.y });

                        if (bodiesUnderPointer.length > 0) {
                            const closestFragment = bodiesUnderPointer[0]; // Simplistic: take the first one

                            // Calculate pointB relative to the fragment's center
                            const pointB = {
                                x: pointer.x - closestFragment.position.x,
                                y: pointer.y - closestFragment.position.y
                            };

                            const initialDistance = Phaser.Math.Distance.Between(lanternSprite.x, lanternSprite.y, pointer.x, pointer.y);
                            
                            tendril = this.matter.add.constraint(lanternSprite.body, closestFragment, initialDistance, 0.05, {
                                damping: 0.01,
                                pointB: pointB
                            });
                            this.matter.world.add(tendril);
                        } else {
                            tendril = null; // No valid fragment to attach to
                        }
                    });

                    this.input.on('pointerup', (pointer) => {
                        if (gameState !== 'playing') return; // Only allow input if playing

                        isTendrilActive = false;
                        if (tendril) {
                            this.matter.world.remove(tendril);
                            tendril = null;
                        }
                        tendrilGraphics.clear();
                    });

                    // Display initial ranking
                    displayRanking();

                    // Add event listener for the clear ranking button
                    const clearButton = document.getElementById('clear-ranking-button');
                    if (clearButton) {
                        clearButton.addEventListener('click', () => {
                            if (confirm('Are you sure you want to clear all local scores?')) {
                                localStorage.removeItem('lanternGameScores');
                                displayRanking(); // Update the displayed ranking
                                console.log('Local scores cleared.');
                            }
                        });
                    }
                },
                update: function () {
                    if (gameState === 'playing') {
                        // Update elapsed time
                        elapsedTime = Math.floor((this.time.now - startTime) / 1000);
                        timerText.setText('Time: ' + elapsedTime + 's');

                        // Game Clear Condition
                        if (lanternSprite.y < 50) {
                            gameState = 'cleared';
                            console.log("Game Clear!");
                            console.log('Final Time: ' + elapsedTime + 's');
                            lanternSprite.setStatic(true);
                            if (tendril) {
                                this.matter.world.remove(tendril);
                                tendril = null;
                                tendrilGraphics.clear();
                            }
                            if (!scoreSubmitted) {
                                scoreSubmitted = true;
                                let playerName = prompt('Game Clear!\nFinal Time: ' + elapsedTime + 's\nEnter your 3-letter initials:', 'AAA');
                                if (playerName && playerName.length > 0) {
                                    playerName = playerName.substring(0, 3).toUpperCase();
                                    const newScore = {
                                        nickname: playerName,
                                        time: elapsedTime,
                                        date: new Date().toISOString().split('T')[0]
                                    };
                                    let scores = JSON.parse(localStorage.getItem('lanternGameScores')) || [];
                                    scores.push(newScore);
                                    scores.sort((a, b) => a.time - b.time);
                                    if (scores.length > 10) {
                                        scores = scores.slice(0, 10);
                                    }
                                    localStorage.setItem('lanternGameScores', JSON.stringify(scores));
                                    console.log('Score saved:', newScore);
                                    alert("Score saved! Refresh to play again.");
                                    location.reload();
                                } else {
                                     alert("No name entered. Score not saved. Refresh to play again.");
                                     location.reload();
                                }
                            }
                        }

                        // Game Over Condition
                        if (lanternSprite.y > config.height + 50) {
                            gameState = 'gameOver';
                            console.log("Game Over!");
                            console.log('Final Time: ' + elapsedTime + 's');
                            lanternSprite.setStatic(true);
                            if (tendril) {
                                this.matter.world.remove(tendril);
                                tendril = null;
                                tendrilGraphics.clear();
                            }
                            if (!scoreSubmitted) {
                                scoreSubmitted = true;
                                let playerName = prompt('Game Over!\nFinal Time: ' + elapsedTime + 's\nEnter your 3-letter initials:', 'AAA');
                                if (playerName && playerName.length > 0) {
                                    playerName = playerName.substring(0, 3).toUpperCase();
                                    const newScore = {
                                        nickname: playerName,
                                        time: elapsedTime,
                                        date: new Date().toISOString().split('T')[0]
                                    };
                                    let scores = JSON.parse(localStorage.getItem('lanternGameScores')) || [];
                                    scores.push(newScore);
                                    scores.sort((a, b) => a.time - b.time);
                                    if (scores.length > 10) {
                                        scores = scores.slice(0, 10);
                                    }
                                    localStorage.setItem('lanternGameScores', JSON.stringify(scores));
                                    console.log('Score saved:', newScore);
                                    alert("Score saved! Refresh to play again.");
                                    location.reload();
                                } else {
                                     alert("No name entered. Score not saved. Refresh to play again.");
                                     location.reload();
                                }
                            }
                        }
                    }

                    // Tendril drawing logic - only if playing and tendril is active
                    if (gameState === 'playing' && isTendrilActive && tendril && tendril.bodyB) {
                        tendrilGraphics.clear();
                        tendrilGraphics.lineStyle(2, 0xffffff, 0.8); // thickness, color, alpha
                        tendrilGraphics.beginPath();
                        tendrilGraphics.moveTo(lanternSprite.x, lanternSprite.y);
                        // Calculate the world coordinates of pointB
                        const pointBWorldX = tendril.bodyB.position.x + tendril.pointB.x;
                        const pointBWorldY = tendril.bodyB.position.y + tendril.pointB.y;
                        tendrilGraphics.lineTo(pointBWorldX, pointBWorldY);
                        tendrilGraphics.strokePath();
                    } else {
                        tendrilGraphics.clear(); // Clear if not playing, tendril not active, or not attached
                    }
                }
            }
        };

        const game = new Phaser.Game(config);
    </script>
</body>
</html>
